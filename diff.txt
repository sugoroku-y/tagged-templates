diff --git a/README.md b/README.md
index d9d7beb..72544b2 100644
--- a/README.md
+++ b/README.md
@@ -225,25 +225,59 @@ const pattern = regexp`^${username}[0-9]*$`;
   // -> /^From: yebisuya@gmail\.com \(YEBISUYA Sugoroku\)\(\)$/
   ```
 
-- 正規表現
+- パターン指定オブジェクト
 
-  正規表現を埋め込む場合は、その正規表現のパターンそのものが埋め込まれます。
+  `source`という名前のプロパティを持つオブジェクトが指定されると、その`source`プロパティに指定された正規表現のパターンそのものが埋め込まれます。
 
   ただし前後に影響を与えないように`(?:～)`で囲まれて挿入されます。
 
-  指定した正規表現にフラグが指定されていた場合、そのフラグ指定がマージされます。
+  正規表現のインスタンスはまさに`source`という名前のプロパティを持つオブジェクトですので、そのまま利用できます。
 
   ```ts
-  const ALPHABET = /[A-Z]/i;
-  const WORD = regexp`${ALPHABET}+`;
-  // -> /(?:[A-Z])+/i
+  const NULL = /null/;
+  const BOOLEAN = /true|false/;
+  const NUMBER = /-?(?:0|[1-9][0-9]*)(?:\.[0-9]+)?(?:[Ee][+-]?[0-])/;
+  const STRING = /"[^"\\]*(?:\\.[^"\\]*)*"/;
+  const PRIMITIVE = regexp/*regexp*/ `${NULL}|${BOOLEAN}|${NUMBER}|${STRING}`;
+  ```
+
+  regexpタグ付きテンプレートで生成した正規表現も、もちろん正規表現のインスタンスなので埋め込みに利用できます。
+
+  ```ts
+  const COMMA_SEPARATED = (begin: string, pattern: RegExp, end: string) => regexp/*regexp*/ `${begin}\s*(?:${pattern}(?:\s*,\s*${pattern})*\s*)?${end}`;
+  const ARRAY = COMMA_SEPARATED('[', PRIMITIVE, ']');
+  const OBJECT = COMMA_SEPARATED('{', regexp/*regexp*/ `${STRING}\s*:\s*${PRIMITIVE}`, '}');
   ```
 
+  このタグ付きテンプレートに埋め込むためにしか使わないのであれば、regexpタグ付きテンプレートを使っていては正規表現のコンパイル処理がムダになります。その代わりに`source`プロパティだけを持つオブジェクトでもほぼ同様の結果が得られます。
+
+  ```ts
+  // 指定の桁数の16進数パターンを生成する(HEXADECIMAL_ESCAPE_SEQUENCEでしか使わないのでregexpタグ付きテンプレートは使わない)
+  const HEXADECIMAL = (n1: number, n2?: number) => ({
+    source: /*regexp*/ `([0-9A-Fa-f]{${n1}${n2 !== undefined ?`,${n2}`: ''}})`
+  });
+  // 16進数エスケープシーケンスのパターン
+  const HEXADECIMAL_ESCAPE_SEQUENCE = regexp/*regexp*/ `\\(?:x${HEXADECIMAL(2)}|u(?:\{${HEXADECIMAL(1,6)}\}|${HEXADECIMAL(4)}))`;
+  ```
+
+  この場合通常のテンプレートリテラルを使うと、特殊文字はエスケープされない、ということに注意してください。
+
+  もちろん正規表現として他の場所で利用することがあるならregexpで生成してください。
+
 - フラグ指定オブジェクト
 
   `flags`という名前のプロパティを持つオブジェクトが指定されると、その`flags`プロパティに指定されたフラグがマージされます。
 
-  ただし、生成される正規表現のパターンには何も影響を与えません。
+  正規表現のインスタンスにも`flags`プロパティがあるため、挿入された正規表現のフラグは継承されます。
+
+  ```ts
+  const ALPHABETS = /[A-Z]/i;
+  const NUMBERS = /[0-9]/;
+  const WORD = regexp`${ALPHABETS}+=${NUMBERS}+`;
+  // -> /(?:[A-Z])+=(?:[0-9])+/i
+  ```
+
+  フラグだけを指定してパターンを追加したくない場合は`flags`プロパティだけを持つオブジェクトを挿入します。
 
   ```ts
   const UPPERCASE = /[A-Z]/;
@@ -251,22 +285,20 @@ const pattern = regexp`^${username}[0-9]*$`;
   // -> /(?:[A-Z])+/i
   ```
 
-### フラグを指定する
-
-生成される正規表現には埋め込まれた正規表現やフラグ指定オブジェクトで指定されている`flags`プロパティをマージしたものが指定されます。
+  正規表現のインスタンスや`flags`プロパティを持つオブジェクトで指定されたフラグはマージした状態で指定されます。
 
-複数の正規表現を埋め込む場合にはそれぞれの正規表現に指定されたフラグがマージされるので、想定した挙動にならない可能性があります。
+  複数の正規表現を埋め込む場合にはそれぞれの正規表現に指定されたフラグがマージされるので、想定した挙動にならない可能性があります。
 
-```ts
-const GLOBAL = /\w+/g;
-const IGNORECASE /[A-Z]/i;
-const pattern = regexp`${GLOBAL}\s*=\s*=${IGNORECASE}+`;
-// -> /(?:\w+)\s*=\s*=(?:[A-Z])+/gi
-```
+  ```ts
+  const UPPERCASE = /[A-Z]/;
+  const ALPHABETS = /[A-Z]/i;
+  const pattern = regexp`${UPPERCASE}+\s*=\s*=${ALPHABETS}+`;
+  // -> /(?:[A-Z])+\s*=\s*=(?:[A-Z])+/i となり、UPPERCASEもALPHABETSも大文字小文字を区別しない正規表現になってしまう
+  ```
 
 ### コメント
 
-1行コメント(`//`から改行まで)やブロックコメント(`/*`から`*/`まで)が指定できます。
+1行コメント(`//`から改行の前まで)やブロックコメント(`/*`から`*/`まで)が指定できます。
 
 ただし、`/`や`*`がエスケープされているとコメントとは見なされません。
 
@@ -288,26 +320,31 @@ const pattern = regexp`
 テンプレートに指定された文字列のうち空白文字(空白、タブ、改行など)は以下のように扱われます。
 
 - エスケープされた空白文字はそのまま残ります。
-- 英数字の間にある連続した空白文字は1つの空白に置換されます。
-  - エスケープシーケンス(`\t`や`\n`など)は含まれません。
-  - 英数字の間にあるコメントについては除去したうえで空白文字が残っていれば1つの空白に置換されます。
-  - 1行コメントは改行の前までをコメントと見なして除去します。
+- 英数字の間にある連続した空白文字は1文字以上の空白文字(`\s+`)に置換されます。
+  - エスケープシーケンスで表記されたもの(`\t`や`\n`など)はここでいう空白文字に含まれません。
+  - コメントについては除去したあとに判定します。
+
+    1行コメントは改行の前までをコメントと見なして除去します。
+- 前後に英数字のない空白文字については除去されます。
 - `${～}`部分については実際に挿入される値が英数字かどうかにかかわらず、何もないものと見なされます。
 
-  つまり直前や直後に空白文字があれば除去されます。
+  つまり`${～}`の直前や直後に空白文字があれば除去されます。
 
 ```ts
 const pattern = regexp`
   abc def    ghi
   jkl mno // line comment
   pqr stu /* block comment
-  */ vwx yz
-  `; // -> /abc def ghi jkl mno pqr stu vwx yz/
+  */ vw/*
+  *  英数字の間にコメントしかない場合はコメントが除去されるだけ
+  */x// 1行コメントは改行文字の前までがコメントであり、コメントを除去しても改行つまり空白文字が残っていると見なされる
+yz
+  `; // -> /abc\s+def\s+ghi\s+jkl\s+mno\s+pqr\s+stu\s+vwx\s+yz/
 ```
 
 ### VS Code の拡張機能
 
-VS Code でこのタグ付きテンプレートを使う場合は`Comment tagged template`をインストールすることをオススメします。
+VS Code でこのタグ付きテンプレートを使う場合は`Comment tagged template`をインストールしておくことをオススメします。
 
 この拡張機能をインストールした上で、以下のように記述すると
 
diff --git a/src/regexp.ts b/src/regexp.ts
index af256ac..8645e9c 100644
--- a/src/regexp.ts
+++ b/src/regexp.ts
@@ -11,7 +11,7 @@ type AllCombination<
 
 export const regexp: TaggedTemplate<
   RegExp,
-  string | RegExp | { flags: AllCombination<'dgimsuy'> }
+  string | { source: string } | { flags: AllCombination<'dgimsuy'> }
 > = function regexp(...args) {
   let flags = '';
   const pattern = args[0].raw
@@ -21,12 +21,12 @@ export const regexp: TaggedTemplate<
     // - コメントは除去
     //   `// aaaaaa` -> 除去
     //   `/* aaaaaa */` -> 除去
-    // - 英数字の間の連続した空白とタブは一つの空白に置換
-    //   `aaa    bbb` -> 'aaa bbb'
+    // - 英数字の間の連続した空白とタブは1文字以上の空白文字(`\s+`)に置換
+    //   `aaa    bbb` -> 'aaa\s+bbb'
     // - その他の空白とタブは除去
     //   `aaa  \n  ` -> 'aaa'
     // - ${~}部分については実際に挿入される値が英数字かどうかにかかわらず、何もないものと見なされる
-    //   つまり直後に空白があれば除去される。
+    //   つまり${~}の直前や直後に空白があれば除去
     .map(s =>
       s.replace(
         /\\[\s\S]|(?<=(\w)?)(?:\/\/.*|\/\*[\s\S]*?\*\/|\s+)+(?=(\w)?)/g,
@@ -35,14 +35,15 @@ export const regexp: TaggedTemplate<
             ? // エスケープされていればそのまま
               match
             : pre && post && match.replace(/\/\/.*|\/\*[\s\S]*?\*\//g, '')
-            ? // 前後に英数字があって、コメント除去しても空文字列でない => 連続した空白があったら一つの空白に
-              ' '
+            ? // 前後に英数字があって、コメント除去しても空文字列でない => 連続した空白があったら1文字以上の空白文字に
+              '\\s+'
             : // その他は削除
               '',
       ),
     )
     .reduce((r, e, i) => {
-      const value = args[i];
+      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
+      const value = args[i]!;
       // フラグが指定されていればマージ
       if (typeof value === 'object' && 'flags' in value) {
         for (const flag of value.flags) {
@@ -52,12 +53,12 @@ export const regexp: TaggedTemplate<
         }
       }
       const pattern =
-        value instanceof RegExp
-          ? // 正規表現はそのパターンをそのまま、ただし前後に影響が出ないように`(?:～)`で囲んで挿入
-            `(?:${value.source})`
-          : typeof value === 'string'
+        typeof value === 'string'
           ? // 文字列が指定されたら正規表現の特殊文字をエスケープして挿入。
             value.replace(/[[\](){}.?+*|^$\\]/g, '\\$&')
+          : 'source' in value
+          ? // 正規表現はそのパターンをそのまま、ただし前後に影響が出ないように`(?:～)`で囲んで挿入
+            `(?:${value.source})`
           : // 上記以外は除去
             '';
       return r.concat(pattern, e);
diff --git a/src/unescape.ts b/src/unescape.ts
index 0a3e774..4b15601 100644
--- a/src/unescape.ts
+++ b/src/unescape.ts
@@ -18,6 +18,23 @@ const UNESCAPE_MAP = {
   '\\0': '\0',
 } as const;
 
+/**
+ * 桁数指定の16進数文字を表す正規表現パターン。キャプチャするところまで含める。
+ * @param n n2が省略されている場合は桁数。n2が指定されている場合は最小桁数。
+ * @param n2 指定した場合は最大桁数。省略時は桁数をnに固定
+ * @returns 生成した正規表現を返す。
+ */
+const HEXADECIMAL = (n1: number, n2?: number) => ({
+  source: /*regexp*/ `([0-9A-Fa-f]{${n1}${n2 !== undefined ? `,${n2}` : ''}})`,
+});
+const HEXADECIMAL_ESCAPE_SEQUENCE = regexp/*regexp*/ `\\(?:x${HEXADECIMAL(
+  2,
+)}|u(?:\{${HEXADECIMAL(1, 6)}\}|${HEXADECIMAL(4)}))`;
+HEXADECIMAL_ESCAPE_SEQUENCE;
+
+/**
+ * エスケープシーケンスの正規表現。
+ */
 const ESCAPE_SEQUENCE = regexp/*regexp*/ `
   // 基本的なエスケープシーケンスはエスケープ文字\とそれに続く1文字
   \\[\s\S](?:
@@ -25,15 +42,15 @@ const ESCAPE_SEQUENCE = regexp/*regexp*/ `
     (?<=0)[0-9]
     |
     // 1文字がxでそのあとに続く2文字が16進数文字であれば追加する
-    (?<=x)([0-9A-Fa-f]{2}) // $1
+    (?<=x)${HEXADECIMAL(2)} // $1
     |
     // 1文字がuでそのあとに続く文字列が以下の場合追加する。
     (?<=u)(?:
       // {～}で囲まれた1～6文字の16進数文字
-      \{([0-9A-Fa-f]{1,6})\} // $2
+      \{${HEXADECIMAL(1, 6)}\} // $2
       |
       // 4文字の16進数文字
-      ([0-9A-Fa-f]{4}) // $3
+      ${HEXADECIMAL(4)} // $3
     )
   )?
   ${{ flags: 'g' }}
diff --git a/test/basic.test.ts b/test/basic.test.ts
index 69a5c2b..ae7053b 100644
--- a/test/basic.test.ts
+++ b/test/basic.test.ts
@@ -1,4 +1,5 @@
 import { basic } from '../src/basic';
+import './toCallConsoleWarnWith';
 
 describe('basic', () => {
   test('simple', () => {
@@ -43,7 +44,11 @@ describe('basic.safe', () => {
     expect(basic.safe`\xabc ${'def'}\tghi\n`).toBe(`\xabc def\tghi\n`);
   });
   test('invalid escape sequence', () => {
-    expect(basic.safe`\xabc ${'def'}\8ghi\n`).toBe(`\xabc def8ghi\n`);
+    expect(() => {
+      expect(basic.safe`\xabc ${'def'}\8ghi\n`).toBe(`\xabc def8ghi\n`);
+    }).toCallConsoleWarnWith(
+      /^\\8 and \\9 are not allowed in indented tagged templates\.\n\\8ghi\\n\n\^\^\n {4}at /,
+    );
   });
   test('basic freezed: raw', () => {
     expect(() => {
diff --git a/test/error.test.ts b/test/error.test.ts
index ec7dff7..b1c4dbc 100644
--- a/test/error.test.ts
+++ b/test/error.test.ts
@@ -1,4 +1,5 @@
 import { error } from '../src/error';
+import './toCallConsoleWarnWith';
 
 describe('error', () => {
   test('exec without parameters', () => {
@@ -23,15 +24,31 @@ describe('error', () => {
     ).toThrow(/^message 123$/);
   });
   test('exec with invalid escape sequence', () => {
-    expect(
-      () =>
-        error`
-          \00\1\2\3\4\5\6\7\8\9\n${
-            // 8進数のエスケープシーケンスはタグ付きテンプレートではコンパイルエラーにならない(rawを使わない場合、実行時エラーになるだけ)
-            '' // 一つ目の${～}より前に不正なUnicodeエスケープシーケンスがあるとTypeScriptでエラーになってしまう
-          }\u{1f38f}\u{110000}\xXX\uXXXXX
-          `,
-    ).toThrow(/^00123456789\n🎏u\{110000\}xXXuXXXXX$/);
+    expect(() => {
+      expect(
+        () =>
+          error`
+            \00\1\2\3\4\5\6\7\8\9\n${
+              // 8進数のエスケープシーケンスはタグ付きテンプレートではコンパイルエラーにならない(rawを使わない場合、実行時エラーになるだけ)
+              '' // 一つ目の${～}より前に不正なUnicodeエスケープシーケンスがあるとTypeScriptでエラーになってしまう
+            }\u{1f38f}\u{110000}\xXX\uXXXXX
+            `,
+      ).toThrow(/^00123456789\n🎏u\{110000\}xXXuXXXXX$/);
+    }).toCallConsoleWarnWith(
+      /^Octal escape sequences are not allowed in indented tagged templates\.\n\\00\\1\\2\\3\\4\\5\\6\\7\\8\\9\\n\n\^\^\^\n {4}at /,
+      /^Octal escape sequences are not allowed in indented tagged templates\.\n\\00\\1\\2\\3\\4\\5\\6\\7\\8\\9\\n\n {3}\^\^\n {4}at /,
+      /^Octal escape sequences are not allowed in indented tagged templates\.\n\\00\\1\\2\\3\\4\\5\\6\\7\\8\\9\\n\n {5}\^\^\n {4}at /,
+      /^Octal escape sequences are not allowed in indented tagged templates\.\n\\00\\1\\2\\3\\4\\5\\6\\7\\8\\9\\n\n {7}\^\^\n {4}at /,
+      /^Octal escape sequences are not allowed in indented tagged templates\.\n\\00\\1\\2\\3\\4\\5\\6\\7\\8\\9\\n\n {9}\^\^\n {4}at /,
+      /^Octal escape sequences are not allowed in indented tagged templates\.\n\\00\\1\\2\\3\\4\\5\\6\\7\\8\\9\\n\n {11}\^\^\n {4}at /,
+      /^Octal escape sequences are not allowed in indented tagged templates\.\n\\00\\1\\2\\3\\4\\5\\6\\7\\8\\9\\n\n {13}\^\^\n {4}at /,
+      /^Octal escape sequences are not allowed in indented tagged templates\.\n\\00\\1\\2\\3\\4\\5\\6\\7\\8\\9\\n\n {15}\^\^\n {4}at /,
+      /^\\8 and \\9 are not allowed in indented tagged templates\.\n\\00\\1\\2\\3\\4\\5\\6\\7\\8\\9\\n\n {17}\^\^\n {4}at /,
+      /^\\8 and \\9 are not allowed in indented tagged templates\.\n\\00\\1\\2\\3\\4\\5\\6\\7\\8\\9\\n\n {19}\^\^\n {4}at /,
+      /^Undefined Unicode code-point\n\\u\{1f38f\}\\u\{110000\}\\xXX\\uXXXXX\n {9}\^{10}\n {4}at /,
+      /^Invalid hexadecimal escape sequence\n\\u\{1f38f\}\\u\{110000\}\\xXX\\uXXXXX\n {19}\^{2}\n {4}at /,
+      /^Invalid Unicode escape sequence\n\\u\{1f38f\}\\u\{110000\}\\xXX\\uXXXXX\n {23}\^{2}\n {4}at /,
+    );
   });
 });
 describe('error.as', () => {
diff --git a/test/indented.test.ts b/test/indented.test.ts
index a07a199..72da45d 100644
--- a/test/indented.test.ts
+++ b/test/indented.test.ts
@@ -1,4 +1,5 @@
 import { indented } from '../src/indented';
+import './toCallConsoleWarnWith';
 
 describe('indented', () => {
   test('empty', () => {
@@ -270,135 +271,237 @@ ${''}
 });
 describe('indented.safe', () => {
   test('empty template', () => {
-    expect(indented.safe``).toBe('');
+    expect(() => {
+      expect(indented.safe``).toBe('');
+    }).toCallConsoleWarnWith(
+      /^There must be a newline character immediately following the leading `\.\n {4}at /,
+    );
   });
   test('The first character is not LF', () => {
-    expect(indented.safe`a
+    expect(() => {
+      expect(indented.safe`a
     `).toBe('a\n    ');
+    }).toCallConsoleWarnWith(
+      /^There must be a newline character immediately following the leading `\.\n {4}at /,
+    );
   });
   test('first template is empty', () => {
-    expect(indented.safe`${''}
+    expect(() => {
+      expect(indented.safe`${''}
     `).toBe('\n    ');
+    }).toCallConsoleWarnWith(
+      /^There must be a newline character immediately following the leading `\.\n {4}at /,
+    );
   });
   test('The template is empty', () => {
-    expect(indented.safe``).toBe('');
+    expect(() => {
+      expect(indented.safe``).toBe('');
+    }).toCallConsoleWarnWith(
+      /^There must be a newline character immediately following the leading `\.\n {4}at /,
+    );
   });
   test('The template is call as function', () => {
-    const template = Object.assign([], { raw: [] });
-    // タグ付きテンプレートの第1引数が空になることはないので無理矢理、空の配列を指定して呼び出し
-    expect(indented.safe(template)).toBe('');
+    expect(() => {
+      const template = Object.assign([], { raw: [] });
+      // タグ付きテンプレートの第1引数が空になることはないので無理矢理、空の配列を指定して呼び出し
+      expect(indented.safe(template)).toBe('');
+    }).toCallConsoleWarnWith(/^Call as a tagged template\.\n {4}at /);
   });
   test('The last template is empty', () => {
-    expect(indented.safe`${''}`).toBe('');
+    expect(() => {
+      expect(indented.safe`${''}`).toBe('');
+    }).toCallConsoleWarnWith(
+      /^There must be a newline character immediately following the leading `\.\n {4}at /,
+    );
   });
   test('The last template does not include LF', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
     ${''}    `).toBe('\n        ');
+    }).toCallConsoleWarnWith(
+      /^There must be no non-whitespace or non-tab characters between the trailing end ` and the beginning of the line\.\n {4}at /,
+    );
   });
   test('The last line is not just spaces and tabs', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
       a`).toBe('\n      a');
+    }).toCallConsoleWarnWith(
+      /^There must be no non-whitespace or non-tab characters between the trailing end ` and the beginning of the line\.\n {4}at /,
+    );
   });
   test('Indentation is uneven', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
     A
   B
     `).toBe('\n    A\n  B\n    ');
+    }).toCallConsoleWarnWith(
+      /^Each line must be blank or begin with the indent at the beginning of the line\.\n {4}at /,
+    );
   });
   test('Indentation is uneven with insert', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
     A
 ${''}
     `).toBe('\n    A\n\n    ');
+    }).toCallConsoleWarnWith(
+      /^Each line must be blank or begin with the indent at the beginning of the line\.\n {4}at /,
+    );
   });
   test('escaped error: unicode', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}abc \uXXXX
           aaaaaa
           `).toBe('abc uXXXX\naaaaaa');
+    }).toCallConsoleWarnWith(
+      /^Invalid Unicode escape sequence\nabc \\uXXXX\n {4}\^{2}\n {4}at /,
+    );
   });
   test('escaped error: Unicode: short', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}abc \uAAA
           aaaaaa
           `).toBe('abc uAAA\naaaaaa');
+    }).toCallConsoleWarnWith(
+      /^Invalid Unicode escape sequence\nabc \\uAAA\n {4}\^{2}\n {4}at /,
+    );
   });
   test('escaped error: invalid Unicode', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}abc \uAAAX
           aaaaaa
           `).toBe('abc uAAAX\naaaaaa');
+    }).toCallConsoleWarnWith(
+      /^Invalid Unicode escape sequence\nabc \\uAAAX\n {4}\^{2}\n {4}at /,
+    );
   });
   test('escaped error: unicode: braced', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}abc \u{XXXX}
           aaaaaa
           `).toBe('abc u{XXXX}\naaaaaa');
+    }).toCallConsoleWarnWith(
+      /^Invalid Unicode escape sequence\nabc \\u\{XXXX\}\n {4}\^{2}\n {4}at /,
+    );
   });
   test('escaped error: unicode: unmatch brace', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}abc \u{XXXX
           aaaaaa
           `).toBe('abc u{XXXX\naaaaaa');
+    }).toCallConsoleWarnWith(
+      /^Invalid Unicode escape sequence\nabc \\u\{XXXX\n {4}\^{2}\n {4}at /,
+    );
   });
   test('escaped error: unicode: empty in brace', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}abc \u{}
           aaaaaa
           `).toBe('abc u{}\naaaaaa');
+    }).toCallConsoleWarnWith(
+      /^Invalid Unicode escape sequence\nabc \\u\{\}\n {4}\^{2}\n {4}at /,
+    );
   });
   test('escaped error: unicode: exceeded', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}abc \u{11ffff}
           aaaaaa
           `).toBe('abc u{11ffff}\naaaaaa');
+    }).toCallConsoleWarnWith(
+      /^Undefined Unicode code-point\nabc \\u\{11ffff\}\n {4}\^{10}\n {4}at /,
+    );
   });
   test('escaped error: hexadecimal', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}abc \xXX
           `).toBe('abc xXX');
+    }).toCallConsoleWarnWith(
+      /^Invalid hexadecimal escape sequence\nabc \\xXX\n {4}\^{2}\n {4}at /,
+    );
   });
   test('escaped error: short hexadecimal', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}abc \xA
           `).toBe('abc xA');
+    }).toCallConsoleWarnWith(
+      /^Invalid hexadecimal escape sequence\nabc \\xA\n {4}\^{2}\n {4}at /,
+    );
   });
   test('escaped error: invalid hexadecimal', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}abc \xAX
           `).toBe('abc xAX');
+    }).toCallConsoleWarnWith(
+      /^Invalid hexadecimal escape sequence\nabc \\xAX\n {4}\^{2}\n {4}at /,
+    );
   });
   test('escaped error: octet escape sequence: \\00', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}\00
           `).toBe('00');
+    }).toCallConsoleWarnWith(
+      /^Octal escape sequences are not allowed in indented tagged templates\.\n\\00\n\^\^\^\n {4}at /,
+    );
   });
   test('escaped error: octet escape sequence: \\09', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}\09
           `).toBe('09');
+    }).toCallConsoleWarnWith(
+      /^Octal escape sequences are not allowed in indented tagged templates\.\n\\09\n\^\^\^\n {4}at /,
+    );
   });
   test('escaped error: octet escape sequence: \\1', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}\1
           `).toBe('1');
+    }).toCallConsoleWarnWith(
+      /^Octal escape sequences are not allowed in indented tagged templates\.\n\\1\n\^\^\n {4}at /,
+    );
   });
   test('escaped error: octet escape sequence: \\7', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}\7
           `).toBe('7');
+    }).toCallConsoleWarnWith(
+      /^Octal escape sequences are not allowed in indented tagged templates\.\n\\7\n\^\^\n {4}at /,
+    );
   });
   test('escaped error: octet escape sequence: \\8', () => {
-    expect(indented.safe`
+    expect(() => {
+      expect(indented.safe`
           ${''}\8
           `).toBe('8');
+    }).toCallConsoleWarnWith(
+      /^\\8 and \\9 are not allowed in indented tagged templates\.\n\\8\n\^\^\n {4}at /,
+    );
   });
   test('escaped error: octet escape sequence: \\9', () => {
-    expect(
-      indented.safe`
+    expect(() => {
+      expect(
+        indented.safe`
           ${''}\9
           `,
-    ).toBe('9');
+      ).toBe('9');
+    }).toCallConsoleWarnWith(
+      /^\\8 and \\9 are not allowed in indented tagged templates\.\n\\9\n\^\^\n {4}at /,
+    );
   });
   test('indented freezed', () => {
     expect(() => {
@@ -454,6 +557,10 @@ describe('sample code', () => {
     expect(xxxRaw()).toBe('aaaaaa\\\nbbbbbb\n\ncccccc');
   });
   test('indented.safe', () => {
-    expect(xxxSafe()).toBe('aaaaaa uXXXX\nbbbbbb\n\ncccccc');
+    expect(() => {
+      expect(xxxSafe()).toBe('aaaaaa uXXXX\nbbbbbb\n\ncccccc');
+    }).toCallConsoleWarnWith(
+      /^Invalid Unicode escape sequence\n\\uXXXX\n\^{2}\n {4}at /,
+    );
   });
 });
diff --git a/test/index.test.ts b/test/index.test.ts
index c597ab2..cc970ec 100644
--- a/test/index.test.ts
+++ b/test/index.test.ts
@@ -1,4 +1,5 @@
 import { basic, error, indented, regexp } from '../src/';
+import './toCallConsoleWarnWith';
 
 describe('import', () => {
   test('basic', () => {
@@ -7,7 +8,11 @@ describe('import', () => {
     expect(basic.raw``).toBe('');
     expect(basic.raw`\a\b\c${''}`).toBe('\\a\\b\\c');
     expect(basic.safe``).toBe('');
-    expect(basic.safe`\a\b\c\8${''}`).toBe('a\bc8');
+    expect(() => {
+      expect(basic.safe`\a\b\c\8${''}`).toBe('a\bc8');
+    }).toCallConsoleWarnWith(
+      /^\\8 and \\9 are not allowed in indented tagged templates\.\n\\a\\b\\c\\8\n {6}\^\^\n {4}at /,
+    );
   });
   test('error', () => {
     expect(() => error``).toThrow(/^$/);
@@ -19,13 +24,17 @@ describe('import', () => {
       c
       `,
     ).toThrow(/^a\nb\nc$/);
-    expect(
-      () => error`
-      a
-      ${'b'}
-      c
-   x   `,
-    ).toThrow(/^\n {6}a\n {6}b\n {6}c\n {3}x {3}$/);
+    expect(() => {
+      expect(
+        () => error`
+        a
+        ${'b'}
+        c
+     x   `,
+      ).toThrow(/^\n {8}a\n {8}b\n {8}c\n {5}x {3}$/);
+    }).toCallConsoleWarnWith(
+      /^There must be no non-whitespace or non-tab characters between the trailing end ` and the beginning of the line\.\n {4}at /,
+    );
   });
   test('indented', () => {
     expect(indented`
diff --git a/test/regexp.test.ts b/test/regexp.test.ts
index bfea897..ab2dd54 100644
--- a/test/regexp.test.ts
+++ b/test/regexp.test.ts
@@ -54,7 +54,7 @@ describe('regexp', () => {
       yz
     `.source,
     ).toBe(
-      '[a-z_][a-z_0-9]*[-+](?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][-+][0-9]+)?abc def ghi jkl mno pqr stu 9vwx0 yz',
+      '[a-z_][a-z_0-9]*[-+](?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][-+][0-9]+)?abc\\s+def\\s+ghi\\s+jkl\\s+mno\\s+pqr\\s+stu\\s+9vwx0\\s+yz',
     );
   });
   test('Escaped comments are not removed', () => {
@@ -76,7 +76,7 @@ describe('regexp', () => {
       regexp/* regexp */ `
       abc def ghi      jkl   mno   pqr stu vwx yz
     `.source,
-    ).toBe('abc def ghi jkl mno pqr stu vwx yz');
+    ).toBe('abc\\s+def\\s+ghi\\s+jkl\\s+mno\\s+pqr\\s+stu\\s+vwx\\s+yz');
   });
   test('insert string and regexp', () => {
     const literal = '[]{}()';
diff --git a/test/toCallConsoleWarnWith.ts b/test/toCallConsoleWarnWith.ts
new file mode 100644
index 0000000..85b9ecc
--- /dev/null
+++ b/test/toCallConsoleWarnWith.ts
@@ -0,0 +1,74 @@
+expect.extend({ toCallConsoleWarnWith });
+
+function toCallConsoleWarnWith(
+  this: jest.MatcherContext,
+  receive: () => unknown,
+  ...strings: (string | RegExp)[]
+): jest.CustomMatcherResult | Promise<jest.CustomMatcherResult> {
+  /** この関数の終了時にrestoreするかどうか */
+  let restorable = true;
+  /** console.warnのモック */
+  const mock = jest
+    .spyOn(console, 'warn')
+    // 出力が邪魔なので何もしない関数に置き換え
+    .mockImplementation(() => undefined);
+  /** テストの結果を返す */
+  const generateResult = () => {
+    const received = mock.mock.calls;
+    // console.warnに渡された引数に指定されたすべての文字列を含むものもしくは正規表現にマッチするものが含まれているか
+    const expected: unknown = expect.arrayContaining(
+      strings.map<unknown>(str =>
+        expect.arrayContaining([
+          typeof str === 'string'
+            ? expect.stringContaining(str)
+            : expect.stringMatching(str),
+        ]),
+      ),
+    );
+    return {
+      pass: this.equals(expected, received),
+      message: () => this.utils.diff(expected, received) ?? '',
+    };
+  };
+  try {
+    const result = receive();
+    if (result instanceof Promise) {
+      // 非同期関数だったのでこの呼び出し内ではrestoreしない
+      restorable = false;
+      return (async () => {
+        try {
+          // 非同期の処理が完了まで待機
+          await result;
+          return generateResult();
+        } finally {
+          // 非同期の処理が完了したのでrestoreする
+          mock.mockRestore();
+        }
+      })();
+    }
+    return generateResult();
+  } finally {
+    if (restorable) {
+      // 非同期でなければここでrestoreする
+      mock.mockRestore();
+    }
+  }
+}
+declare global {
+  // eslint-disable-next-line @typescript-eslint/no-namespace
+  namespace jest {
+    interface Matchers<R, T> {
+      toCallConsoleWarnWith(
+        ...args: T extends () => unknown
+          ? (string | RegExp)[]
+          : [] & 'expectには関数を指定してください'
+      ): T extends () => infer TR
+        ? TR extends Promise<unknown>
+          ? Promise<R>
+          : R
+        : never;
+    }
+  }
+}
+
+export {};
